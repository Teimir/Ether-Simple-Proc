
# Instruction Set Architecture (v1.2)

## 1. Регистры и флаги

### Регистры процессора
| Регистр | Размер | Описание                          |
|---------|--------|-----------------------------------|
| A,B,C,D | 8-bit  | РОН (кодировка: 00,01,10,11)     |
| PC      | 16-bit | Счетчик команд                    |
| FLAGS   | 8-bit  | Флаги состояния                  |

### Регистр флагов (FLAGS)
| Бит | Мнемоника | Описание                          |
|-----|-----------|-----------------------------------|
| 0   | Z         | Результат равен нулю             |
| 1   | C         | Перенос/заем                     |
| 2   | V         | Переполнение знакового бита      |
| 3   | S         | Знаковый бит (1 = отрицательный) |
| 4   | IF        | Разрешение прерываний            |

## 2. Адресные пространства

### Память (16-bit адресация)
- **Диапазон:** 0x0000-0xFFFF
- **Особенности:** 
  - Big Endian формат
  - Доступ через MOV, PUSH/POP

### Устройства ввода-вывода
- **Порты:** 0x00-0xFF (8-bit)
- **Инструкции:** IN, OUT

## 3. Система команд (на основе core.sv)

### Форматы команд
| Тип       | Длина | Пример                    | Кодировка             |
|-----------|-------|---------------------------|-----------------------|
| RR        | 1B    | `ADD A,B`                 | 0x21                  |
| IMM8      | 2B    | `MOV A,0x55`              | 0x70 0x55            |
| ADDR16    | 3B    | `JMP 0x1234`              | 0xD0 0x12 0x34       |
| INDEXED   | 2B    | `MOV [B+C],A`             | 0x74 0x13            |

### Полная таблица операций
| Мнемоника         | OPCODE | Формат       | Особенности                      |
|-------------------|--------|--------------|----------------------------------|
| **MOV**           |        |              |                                  |
| MOV R1,R2         | 0x10   | RR           | Копирование между регистрами    |
| MOV R,IMM8        | 0x70   | IMM8         |                                  |
| MOV [ADDR16],R    | 0x9X   | ADDR16       | X = регистр (0-3)               |
| MOV R,[R1+R2]     | 0x7C   | INDEXED      | Адрес = R1:R2                   |
| **Арифметика**                                                              |
| ADD R1,R2         | 0x20   | RR           | Обновляет Z,C,V,S               |
| SUB R1,R2         | 0x30   | RR           |                                  |
| AND/OR/XOR R1,R2  | 0x40-60| RR           |                                  |
| **Управление**    |        |              |                                  |
| JMP ADDR16        | 0xD0   | ADDR16       | Безусловный переход             |
| JZ/JC ADDR16      | 0xD1-D2| ADDR16       | Условные переходы               |
| HALT              | 0xEF   | 1B           | Останов процессора              |
| **Прерывания**    |        |              |                                  |
| EI                | 0xE2   | 1B           | IF ← 1                          |
| DI                | 0xE3   | 1B           | IF ← 0                          |
| RETI              | 0xE1   | 1B           | Восстановление PC и FLAGS       |
| **I/O**           |        |              |                                  |
| IN R,PORT8        | 0xBX   | PORT8        | X = регистр (0-3)               |
| OUT PORT8,R       | 0xCX   | PORT8        |                                 |

## 4. Механизм прерываний

### Этапы обработки:
1. При активации `irq_i` и IF=1:
   - Сохранить PC (2 байта) и FLAGS
   - Переход по адресу из IVT (0xFFFE)
   - IF ← 0

2. Состояния FSM:
```
INT_SAVE1_S → INT_SAVE2_S → INT_SAVE3_S → INT_JUMP_S
```

3. Возврат:
- `RETI` восстанавливает PC, FLAGS и устанавливает IF=1


## 5. Примеры программ

### Вывод символа через порт
```asm
MOV A, 0x41     ; 'A' → A (0x70 0x41)
OUT 0x01, A     ; Вывод в порт 0x01 (0xC0 0x01)
HALT            ; Останов (0xEF)
```

### Работа с памятью
```asm
MOV [0x1234], A ; Запись в память (0x90 0x12 0x34)
MOV B, [C+D]    ; Чтение с индексом (0x7C 0x23)
```

## 6. Системные адреса
| Назначение       | Адрес     |
|-------------------|-----------|
| Вектор прерываний | 0xFFFE    |

---

**Примечания:**
- Все 16-битные адреса кодируются в Big Endian
- Составные адреса [R1+R2] используют регистры как старший/младший байт
- HALT активируется через специальный код 0xEF и требует сброса
