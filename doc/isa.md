# Полное описание Instruction Set Architecture (ISA)

1. Регистры


| Регистр | Размер (бит) | Описание                                                                                         |
| -------------- | --------------------- | -------------------------------------------------------------------------------------------------------- |
| `A, B, C, D`   | 8                     | Регистры общего назначения (РОН).                                             |
| `PC`           | 16                    | Счётчик команд. Указывает адрес следующей инструкции.      |
| `SP`           | 16                    | Указатель стека (растёт вниз).                                                   |
| `FLAGS`        | 8                     | Регистр флагов:                                                                             |
|                |                       | -`Z` (бит 0): Zero (результат = 0).                                                          |
|                |                       | -`C` (бит 1): Carry (перенос/заём).                                                        |
|                |                       | -`V` (бит 2): Overflow (переполнение знакового бита).                        |
|                |                       | -`S` (бит 3): Sign (1 = отрицательный).                                                  |
|                |                       | -`IF` (бит 4): Interrupt Flag (1 = прерывания разрешены).                          |
| `IVT`          | 16                    | Вектор прерываний (адрес обработчика). По умолчанию:`0xFFFE`. |

---

#### **2. Адресные пространства**

1. **Память (RAM/ROM)**

   - **Диапазон:** `0x0000` – `0xFFFF` (16 бит, 64 КБ).
   - **Доступ:** Через инструкции `MOV`, `PUSH`, `POP`.
2. **Устройства (I/O-порты)**

   - **Диапазон:** `0x00` – `0xFF` (8 бит, 256 портов).
   - **Доступ:** Только через `IN` и `OUT`.

---

#### **3. Система команд**

##### **Категории инструкций:**


| Категория       | Инструкция | Описание                                                                         | Пример      |
| ------------------------ | -------------------- | ---------------------------------------------------------------------------------------- | ----------------- |
| **Пересылка**   | `MOV R1, R2`         | `R1 ← R2`                                                                               | `MOV A, B`        |
|                          | `MOV R, IMM8`        | `R ← IMM8`                                                                              | `MOV C, 0x55`     |
|                          | `MOV [ADDR16], R`    | Запись в память                                                             | `MOV [0x1000], A` |
|                          | `MOV R, [ADDR16]`    | Чтение из памяти                                                           | `MOV B, [0x2000]` |
| **Арифметика** | `ADD R1, R2`         | `R1 ← R1 + R2` (обновляет `Z, C, V, S`)                                        | `ADD A, B`        |
|                          | `SUB R1, R2`         | `R1 ← R1 - R2`                                                                          | `SUB C, D`        |
|                          | `INC R`              | `R ← R + 1`                                                                             | `INC D`           |
| **Логика**         | `AND R1, R2`         | `R1 ← R1 & R2`                                                                          | `AND A, B`        |
|                          | `OR R1, R2`          | `R1 ← R1                                                                                | R2`               |
|                          | `XOR R1, R2`         | `R1 ← R1 ^ R2`                                                                          | `XOR A, B`        |
| **Сдвиги**         | `SHL R`              | Логический сдвиг влево (`C` = вытесненный бит)         | `SHL A`           |
| **Управление** | `JMP ADDR16`         | Безусловный переход                                                    | `JMP 0x1234`      |
|                          | `JZ ADDR16`          | Переход, если`Z=1`                                                            | `JZ 0x5678`       |
|                          | `JC ADDR16`          | Переход, если`C=1`                                                            | `JC 0x9ABC`       |
|                          | `JNZ ADDR16`         | Переход, если`Z=0`                                                            | `JNZ 0xDEF0`      |
|                          | `CALL ADDR16`        | Вызов подпрограммы                                                      | `CALL 0x1357`     |
|                          | `RET`                | Возврат из подпрограммы                                             | `RET`             |
| **Стек**             | `PUSH R`             | `SP ← SP - 2`, `[SP] ← R`                                                              | `PUSH A`          |
|                          | `POP R`              | `R ← [SP]`, `SP ← SP + 2`                                                              | `POP B`           |
| **Прерывания** | `EI`                 | Разрешить прерывания (`IF ← 1`)                                      | `EI`              |
|                          | `DI`                 | Запретить прерывания (`IF ← 0`)                                      | `DI`              |
|                          | `RETI`               | Возврат из прерывания (восстанавливает`PC` и `FLAGS`) | `RETI`            |
| **I/O**                  | `IN R, PORT8`        | Чтение из порта в регистр                                           | `IN A, 0x01`      |
|                          | `OUT PORT8, R`       | Запись регистра в порт                                                | `OUT 0x02, B`     |

---

#### **4. Кодировка инструкций**

##### **Форматы:**

1. **Один байт:**

   - Примеры: `RET` (`0xC9`), `EI` (`0xFB`), `DI` (`0xFA`).
2. **Два байта:**

   - `OPCODE + IMM8` (например, `MOV R, IMM8`).
   - `OPCODE + PORT8` (например, `IN A, 0x01` → `0x5A 0x01`).
3. **Три байта:**

   - `OPCODE + ADDR16` (little-endian, например, `JMP 0x1234` → `0xE9 0x34 0x12`).

##### **Примеры кодировки:**


| Инструкция | Код (HEX)     | Описание               |
| -------------------- | ---------------- | ------------------------------ |
| `MOV A, B`           | `0x12`           | `0x1` = MOV, `0x2` = A←B      |
| `ADD A, 0x55`        | `0x21 0x55`      | `0x21` = ADD с IMM8           |
| `JMP 0x1234`         | `0xE9 0x34 0x12` | Little-endian адрес       |
| `IN A, 0x01`         | `0x5A 0x01`      | `0x5A` = IN, `0x01` = порт |

---

#### **5. Механизм прерываний**

1. **Активация прерывания:**

   - Устройство отправляет сигнал на выделенную линию.
   - Если `IF=1`, процессор:
     - Сохраняет `PC` и `FLAGS` в стек.
     - Устанавливает `IF=0`.
     - Переходит по адресу из `IVT` (по умолчанию `0xFFFE`).
2. **Обработчик прерывания:**

   - Должен сохранять/восстанавливать регистры (если нужно).
   - Завершается инструкцией `RETI` (восстанавливает `PC`, `FLAGS`, включает `IF`).

---

#### **6. Примеры программ**

##### **a) Вывод символа 'A' на дисплей:**

```asm
MOV A, 0x41      ; 'A' → A
OUT 0x01, A      ; Вывод в порт дисплея (0x01)
HALT
```

##### **b) Обработка прерывания от клавиатуры:**

```asm
ORG 0xFFFE       ; Адрес обработчика
  PUSH A         ; Сохраняем регистр
  IN A, 0x00     ; Чтение с порта клавиатуры (0x00)
  MOV [0x1000], A ; Сохраняем символ в память
  POP A  
  RETI           ; Возврат
```

##### **c) Условный переход по переполнению:**

```asm
ADD A, B         ; A = A + B
JV OVERFLOW      ; Переход, если V=1
...              ; Основная логика
OVERFLOW:
  MOV [0xFF01], 0xEE ; Сигнал ошибки
```

---

#### **7. Особенности архитектуры**

- **Разделение памяти и устройств:**
  - Память: 16-битные адреса, доступ через `MOV`.
  - Устройства: 8-битные порты, доступ через `IN`/`OUT`.
- **Одноуровневые прерывания:** Новое прерывание блокируется до завершения текущего.
- **Флаги:** Обновляются после арифметических и логических операций.
- big endian

---

#### **8. Сравнение с Memory-Mapped I/O**


| Параметр             | **Разделение (IN/OUT)**              | **Memory-Mapped I/O**                   |
| ---------------------------- | ---------------------------------------------- | --------------------------------------- |
| **Безопасность** | Выше (изоляция устройств) | Ниже                                |
| **Гибкость**         | 256 портов                               | Любые адреса в памяти |
| **Примеры**           | x86 (порты COM)                           | ARM (MMIO)                              |

---

### **Итог**

Данная ISA подходит для учебных проектов, простых микроконтроллеров или embedded-систем. Чёткое разделение памяти и устройств, поддержка прерываний и условных переходов делают её гибкой и безопасной.
