# Полное описание Instruction Set Architecture (ISA)

1. Регистры


| Регистр | Размер (бит) | Описание                                                                                                                 |
| -------------- | --------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| `A, B, C, D`   | 8                     | Регистры общего назначения (РОН). Кодируются 2 битами:`A=00`, `B=01`, `C=10`, `D=11`. |
| `PC`           | 16                    | Счётчик команд. Указывает адрес следующей инструкции.                              |
| `SP`           | 16                    | Указатель стека (растёт вниз).                                                                           |
| `FLAGS`        | 8                     | Регистр флагов:                                                                                                     |
|                |                       | -`Z` (бит 0): Zero (результат = 0).                                                                                  |
|                |                       | -`C` (бит 1): Carry (перенос/заём).                                                                                |
|                |                       | -`V` (бит 2): Overflow (переполнение знакового бита).                                                |
|                |                       | -`S` (бит 3): Sign (1 = отрицательный).                                                                          |
|                |                       | -`IF` (бит 4): Interrupt Flag (1 = прерывания разрешены).                                                  |
| `IVT`          | 16                    | Вектор прерываний (адрес обработчика). По умолчанию:`0xFFFE`.                         |

---

#### **2. Адресные пространства**

1. **Память (RAM/ROM)**
   - **Диапазон:** `0x0000` – `0xFFFF` (16 бит, 64 КБ).
   - **Доступ:** Через инструкции `MOV`, `PUSH`, `POP`.
2. **Устройства (I/O-порты)**
   - **Диапазон:** `0x00` – `0xFF` (8 бит, 256 портов).
   - **Доступ:** Только через `IN` и `OUT`.

---

#### **3. Система команд**

##### **Категории инструкций:**


| Категория       | Инструкция | Описание                                                                                     | Пример                          |
| ------------------------ | -------------------- | ---------------------------------------------------------------------------------------------------- | ------------------------------------- |
| **Пересылка**   | `MOV R1, R2`         | `R1 ← R2` (RR-формат, 1 байт)                                                             | `MOV A, B` → `0x11`                  |
|                          | `MOV R, IMM8`        | `R ← IMM8` (2 байта: `OP + IMM8`)                                                              | `MOV B, 0xFF` → `0x71 0xFF`          |
|                          | `MOV [ADDR16], R`    | Запись в память (3 байта:`OP + ADDR16`, Big Endian)                                | `MOV [0x1234], A` → `0x90 0x12 0x34` |
|                          | `MOV R, [ADDR16]`    | Чтение из памяти (3 байта:`OP + ADDR16`, Big Endian)                              | `MOV B, [0x5678]` → `0xA1 0x56 0x78` |
| **Арифметика** | `ADD R1, R2`         | `R1 ← R1 + R2` (RR-формат, 1 байт, обновляет `Z, C, V, S`)                       | `ADD C, D` → `0x2B`                  |
|                          | `SUB R1, R2`         | `R1 ← R1 - R2` (RR-формат, 1 байт)                                                        | `SUB B, A` → `0x34`                  |
|                          | `AND R1, R2`         | `R1 ← R1 & R2` (RR-формат, 1 байт)                                                        | `AND D, C` → `0x4E`                  |
|                          | `OR R1, R2`          | `R1 ← R1                                                                                            | R2` (RR-формат, 1 байт)     |
|                          | `XOR R1, R2`         | `R1 ← R1 ^ R2` (RR-формат, 1 байт)                                                        | `XOR B, C` → `0x66`                  |
| **Управление** | `JMP ADDR16`         | Безусловный переход (3 байта:`OP + ADDR16`, Big Endian)                       | `JMP 0x1234` → `0xD0 0x12 0x34`      |
|                          | `JZ ADDR16`          | Переход, если`Z=1` (3 байта: `OP + ADDR16`, Big Endian)                              | `JZ 0x5678` → `0xD1 0x56 0x78`       |
|                          | `JC ADDR16`          | Переход, если`C=1` (3 байта: `OP + ADDR16`, Big Endian)                              | `JC 0x9ABC` → `0xD2 0x9A 0xBC`       |
|                          | `CALL ADDR16`        | Вызов подпрограммы (3 байта:`OP + ADDR16`, Big Endian)                         | `CALL 0x1357` → `0xD3 0x13 0x57`     |
|                          | `RET`                | Возврат из подпрограммы (1 байт)                                            | `RET` → `0xE0`                       |
| **Прерывания** | `EI`                 | Разрешить прерывания (`IF ← 1`, 1 байт)                                      | `EI` → `0xE2`                        |
|                          | `DI`                 | Запретить прерывания (`IF ← 0`, 1 байт)                                      | `DI` → `0xE3`                        |
|                          | `RETI`               | Возврат из прерывания (восстанавливает`PC` и `FLAGS`, 1 байт) | `RETI` → `0xE1`                      |
| **I/O**                  | `IN R, PORT8`        | Чтение из порта в регистр (2 байта:`OP + PORT8`)                           | `IN C, 0x02` → `0xB2 0x02`           |
|                          | `OUT PORT8, R`       | Запись регистра в порт (2 байта:`OP + PORT8`)                                | `OUT 0x03, D` → `0xC3 0x03`          |
| **Остальные**   | `NOP`                | Пустая операция (1 байт)                                                           | `NOP` → `0x00`                       |
|                          | `HALT`               | Остановка процессора (1 байт)                                                 | `HALT` → `0xEF`                      |

---

#### **4. Кодировка инструкций**

##### **Форматы:**

1. **Один байт:**
   - Примеры: `RET` (`0xE0`), `EI` (`0xE2`), `DI` (`0xE3`), `NOP` (`0x00`), `HALT` (`0xEF`).
2. **Два байта:**
   - `OPCODE + IMM8` (например, `MOV R, IMM8` → `0x70 + R`).
   - `OPCODE + PORT8` (например, `IN R, PORT8` → `0xB0 + R`).
3. **Три байта:**
   - `OPCODE + ADDR16` (Big Endian, например, `JMP 0x1234` → `0xD0 0x12 0x34`).

##### **Примеры кодировки:**


| Инструкция | Код (HEX)     | Описание                                 |
| -------------------- | ---------------- | ------------------------------------------------ |
| `MOV A, B`           | `0x11`           | `0x10` (MOV) + `00` (A) + `01` (B)               |
| `ADD A, 0x55`        | `0x80 0x55`      | `0x80` (ADD IMM8) + `0x55` (значение)    |
| `JMP 0x1234`         | `0xD0 0x12 0x34` | `0xD0` (JMP) + Big Endian адрес             |
| `IN A, 0x01`         | `0xB0 0x01`      | `0xB0` (IN) + `0x01` (порт)                  |
| `MOV [0x1234], A`    | `0x90 0x12 0x34` | `0x90` (MOV [ADDR16], R) + Big Endian адрес |

---

#### **5. Механизм прерываний**

1. **Активация прерывания:**
   - Устройство отправляет сигнал на выделенную линию.
   - Если `IF=1`, процессор:
     - Сохраняет `PC` и `FLAGS` в стек.
     - Устанавливает `IF=0`.
     - Переходит по адресу из `IVT` (по умолчанию `0xFFFE`).
2. **Обработчик прерывания:**
   - Должен сохранять/восстанавливать регистры (если нужно).
   - Завершается инструкцией `RETI` (восстанавливает `PC`, `FLAGS`, включает `IF`).

---

#### **6. Примеры программ**

##### **a) Вывод символа 'A' на дисплей:**

```asm
MOV A, 0x41      ; 'A' → A (код: 0x70 0x41)
OUT 0x01, A      ; Вывод в порт дисплея (0x01) (код: 0xC0 0x01)
HALT             ; Остановка (код: 0xEF)
```

##### **b) Обработка прерывания от клавиатуры:**

```asm
ORG 0xFFFE       ; Адрес обработчика
  PUSH A         ; Сохраняем регистр
  IN A, 0x00     ; Чтение с порта клавиатуры (0x00) (код: 0xB0 0x00)
  MOV [0x1000], A ; Сохраняем символ в память (код: 0x90 0x10 0x00)
  POP A  
  RETI           ; Возврат (код: 0xE1)
```

##### **c) Условный переход по переполнению:**

```asm
ADD A, B         ; A = A + B (код: 0x21)
JV OVERFLOW      ; Переход, если V=1 (код: 0xD2 + адрес)
...              ; Основная логика
OVERFLOW:
  MOV [0xFF01], 0xEE ; Сигнал ошибки (код: 0x90 0xFF 0x01 + 0x70 0xEE)
```

---

#### **7. Особенности архитектуры**

- **Big Endian:** Старший байт записывается первым (например, адрес `0x1234` кодируется как `0x12 0x34`).
- **Разделение памяти и устройств:**
  - Память: 16-битные адреса, доступ через `MOV`.
  - Устройства: 8-битные порты, доступ через `IN`/`OUT`.
- **Одноуровневые прерывания:** Новое прерывание блокируется до завершения текущего.
- **Флаги:** Обновляются после арифметических и логических операций.
