### **Полная сводка кодировок**

### **Таблица побитного кодирования операций (Big Endian)**

#### **1. Общие принципы**

- **Big Endian:** Старший байт записывается **первым** (например, `0x1234` → `0x12 0x34`).
- **Регистры:** Кодируются **2 битами** (`A=00`, `B=01`, `C=10`, `D=11`).
- **Форматы команд:**
  - **1B:** `OPCODE` (например, `NOP`, `RET`).
  - **2B:** `OPCODE + IMM8/PORT8` (например, `MOV R, IMM8`, `IN R, PORT8`).
  - **3B:** `OPCODE + ADDR16` (например, `JMP ADDR16`, `MOV [ADDR16], R`).
  - **RR:** `OPCODE + REG1 + REG2` (например, `ADD R1, R2`).

---

### **2. Кодировка операций**

#### **Арифметико-логические операции (RR-формат, 1 байт)**


| Команда | OPCODE (HEX) | Бинарный вид (`OP + R1 + R2`) | Пример (`A, B`)                 |
| -------------- | ------------ | ---------------------------------------- | ------------------------------------- |
| `MOV`          | `0x10`       | `0001 R1 R2`                             | `MOV A, B` → `0001 0000 01` (`0x11`) |
| `ADD`          | `0x20`       | `0010 R1 R2`                             | `ADD C, D` → `0010 0010 11` (`0x2B`) |
| `SUB`          | `0x30`       | `0011 R1 R2`                             | `SUB B, A` → `0011 0001 00` (`0x34`) |
| `AND`          | `0x40`       | `0100 R1 R2`                             | `AND D, C` → `0100 0011 10` (`0x4E`) |
| `OR`           | `0x50`       | `0101 R1 R2`                             | `OR A, D` → `0101 0000 11` (`0x53`)  |
| `XOR`          | `0x60`       | `0110 R1 R2`                             | `XOR B, C` → `0110 0001 10` (`0x66`) |
| cmp            | 0xA0         | 1011 R1 R2                               | CMP A, B -> ////                      |

#### **Операции с непосредственным значением (2B, `OP + IMM8`)**


| Команда | OPCODE (HEX) | Формат (`OP + IMM8`)  | Пример (`A, 0x55`)     |
| -------------- | ------------ | --------------------------- | ---------------------------- |
| `MOV`          | `0x70`       | `0111 00 R1` + `IMM8`       | `MOV B, 0xFF` → `0x71 0xFF` |
| `ADD`          | `0x80`       | `1000 00 R1` + `IMM8`       | `ADD A, 0x55` → `0x80 0x55` |
| ``MOV``        | ``0x74``     | ``0111 01 r1 + 0000 r2 r3`` | mov [r2+r3] r1               |
| ``MOV``        | ``0x7C``     | ``0111 11 r1 + 0000 r2 r3`` | mov r1 [r2+r3]               |

#### **Операции с памятью (3B, Big Endian `OP + ADDR16`)**


| Команда    | OPCODE (HEX) | Формат (`OP + ADDR16`) | Пример (`[0x1234], A`)          |
| ----------------- | ------------ | ---------------------------- | ------------------------------------- |
| `MOV [ADDR16], R` | `0x90`       | `1001 00 R1` + `ADDR16`      | `MOV [0x1234], A` → `0x90 0x12 0x34` |
| `MOV R, [ADDR16]` | `0x90`       | `1001 01 R1` + `ADDR16`      | `MOV B, [0x5678]` → `0xA1 0x56 0x78` |

#### **Операции ввода-вывода (2B, `OP + PORT8`) INOP**


| Команда | OPCODE (HEX) | Формат (`OP + PORT8`) | Пример (`A, 0x01`)     |
| -------------- | ------------ | --------------------------- | ---------------------------- |
| `IN`           | `0xB0`       | `1011 00 R1` + `PORT8`      | `IN C, 0x02` → `0xB2 0x02`  |
| `OUT`          | `0xC0`       | `1100 00 R1` + `PORT8`      | `OUT 0x03, D` → `0xC3 0x03` |

#### **Управление потоком (3B, Big Endian `OP + ADDR16`)**


| Команда | OPCODE (HEX) | Формат (`OP + ADDR16`) | Пример (`0x1234`)          |
| -------------- | ------------ | ---------------------------- | -------------------------------- |
| `JMP`          | `0xD0`       | `1101 0000` + `ADDR16`       | `JMP 0x1234` → `0xD0 0x12 0x34` |
| `JZ`           | `0xD1`       | `1101 0001` + `ADDR16`       | `JZ 0x5678` → `0xD1 0x56 0x78`  |
| `JC`           | `0xD2`       | `1101 0010` + `ADDR16`       | `JC 0x9ABC` → `0xD2 0x9A 0xBC`  |

#### **Одно-байтовые команды**


| Команда | OPCODE (HEX) | Бинарный вид | Описание                             |
| -------------- | ------------ | ----------------------- | -------------------------------------------- |
| `NOP`          | `0x00`       | `0000 0000`             | Пустая операция                |
| `RET`          | `0xE0`       | `1110 0000`             | Возврат из подпрограммы |
| halt           | 0xEF         | 1110 1111               | Стоп                                     |
| `RETI`         | `0xE1`       | `1110 0001`             | Возврат из прерывания     |
| `EI`           | `0xE2`       | `1110 0010`             | Разрешить прерывания      |
| `DI`           | `0xE3`       | `1110 0011`             | Запретить прерывания      |

---

### **3. Примеры кодировки в Big Endian**

#### **Пример 1:** `MOV [0x1234], A`

1. `MOV [ADDR16], R` → `0x90` (`1001 0000`).
2. Регистр `A` → `00`.
3. Адрес `0x1234` → `0x12 0x34` (Big Endian).
4. Итоговый код: `0x90 0x12 0x34`.

#### **Пример 2:** `JMP 0x5678`

1. `JMP` → `0xD0` (`1101 0000`).
2. Адрес `0x5678` → `0x56 0x78`.
3. Итоговый код: `0xD0 0x56 0x78`.

#### **Пример 3:** `ADD A, B`

1. `ADD` → `0x20` (`0010 0000`).
2. Регистр `A` → `00`.
3. Регистр `B` → `01`.
4. Итоговый код: `0010 0000 01` → `0x21`.

---

### **4. Сравнение Big Endian vs Little Endian**


| Команда    | Big Endian (`0x1234`) | Little Endian (`0x1234`) |
| ----------------- | --------------------- | ------------------------ |
| `MOV [ADDR16], A` | `0x90 0x12 0x34`      | `0x90 0x34 0x12`         |
| `JMP 0x5678`      | `0xD0 0x56 0x78`      | `0xD0 0x78 0x56`         |

---

### **5. Итог**

- **Big Endian** старший байт записывается **первым**, что упрощает чтение дампов памяти.
- Все **16-битные адреса** в командах (например, `JMP`, `MOV [ADDR16]`) следуют этому правилу.
- **Регистровые операции** (RR-формат) остаются **1-байтовыми** и не зависят от порядка байт.

Такой формат подходит для систем, где требуется совместимость с сетевыми протоколами (например, TCP/IP) или процессорами с Big Endian-архитектурой (например, Motorola 68000).

#### **Арифметико-логические операции (RR-формат)**

```python
MOV R1, R2  = 0001 R1 R2  (0x10 + (R1 << 2) + R2)
ADD R1, R2  = 0010 R1 R2  (0x20 + (R1 << 2) + R2)
SUB R1, R2  = 0011 R1 R2  (0x30 + (R1 << 2) + R2)
AND R1, R2  = 0100 R1 R2  (0x40 + (R1 << 2) + R2)
OR  R1, R2  = 0101 R1 R2  (0x50 + (R1 << 2) + R2)
XOR R1, R2  = 0110 R1 R2  (0x60 + (R1 << 2) + R2)
```

#### **Операции с памятью и устройствами**

```python
# Memory operations (Big Endian)
MOV [ADDR16], R = 1001 00 R1 + ADDR16 (0x90 + R1, [0x12, 0x34])
MOV R, [ADDR16] = 1010 00 R1 + ADDR16 (0xA0 + R1, [0x12, 0x34])

# I/O operations
IN  R, PORT8    = 1011 00 R1 + PORT8  (0xB0 + R1, 0x01)
OUT PORT8, R    = 1100 00 R1 + PORT8  (0xC0 + R1, 0x02)
```

#### **Управление потоком**

```python
JMP  ADDR16 = 1101 0000 + ADDR16 (0xD0, [0x12, 0x34])
JZ   ADDR16 = 1101 0001 + ADDR16 (0xD1, [0x12, 0x34])
JC   ADDR16 = 1101 0010 + ADDR16 (0xD2, [0x12, 0x34])
CALL ADDR16 = 1101 0011 + ADDR16 (0xD3, [0x12, 0x34])
```

---

### **3. Примеры с `HALT`**

#### Программа с остановкой:

```asm
MOV A, 0x01
OUT 0x01, A  ; Вывод в порт
HALT         ; Остановка (код 0xEF)
```

#### Дамп памяти:

```
Адрес   | Данные
--------|-------
0x0000  | 0x70   ; MOV A, IMM8
0x0001  | 0x01   ; Значение 0x01
0x0002  | 0xC0   ; OUT PORT8, A
0x0003  | 0x01   ; Порт 0x01
0x0004  | 0xEF   ; HALT
```

---

### **4. Особенности кодировки `HALT`**

- **Код `0xEF`** (`1110 1111`) выбран для:
  - Легкого распознавания в дампах памяти.
  - Отсутствия конфликтов с другими OPCODE.
- **Семантика:**
  - Останавливает тактовый генератор процессора.
  - Требует сброса или прерывания для продолжения работы.
