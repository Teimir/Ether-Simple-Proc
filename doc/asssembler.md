Вот исправленный файл `assembler.md` с учетом полной сводки кодировок:

```markdown
# Ассемблер для 8-битного процессора (Big Endian)

Этот ассемблер преобразует текстовый код на ассемблере в бинарный машинный код для 8-битного процессора с архитектурой Big Endian.

## Особенности

- Полная поддержка Big Endian (старший байт записывается первым)
- Поддержка меток (labels)
- Директива `ORG` для указания адреса размещения кода
- Двухпроходная компиляция
- Поддержка шестнадцатеричных (`0x`), двоичных (`0b`) и десятичных чисел
- Проверка ошибок (переполнение, неизвестные команды, синтаксические ошибки)

## Система команд

### 1. Форматы команд

| Тип       | Длина | Формат                     | Примеры                     |
|-----------|-------|----------------------------|-----------------------------|
| RR        | 1B    | `OPCODE + R1 + R2`         | `MOV A, B` (`0x10`)         |
| IMM8      | 2B    | `OPCODE + IMM8`            | `MOV A, 0x55` (`0x70 0x55`)|
| ADDR16    | 3B    | `OPCODE + ADDR16`          | `JMP 0x1234` (`0xD0 0x12 0x34`)|
| PORT8     | 2B    | `OPCODE + PORT8`           | `IN A, 0x01` (`0xB0 0x01`) |
| No args   | 1B    | `OPCODE`                   | `NOP` (`0x00`)             |

### 2. Полная таблица команд

#### Арифметико-логические операции

| Команда | Формат | Код (HEX) | Пример кодировки          |
|---------|--------|-----------|---------------------------|
| MOV     | RR     | 0x10      | `MOV A, B` → `0x11`       |
| ADD     | RR     | 0x20      | `ADD C, D` → `0x2B`       |
| SUB     | RR     | 0x30      | `SUB B, A` → `0x34`       |
| AND     | RR     | 0x40      | `AND D, C` → `0x4E`       |
| OR      | RR     | 0x50      | `OR A, D` → `0x53`        |
| XOR     | RR     | 0x60      | `XOR B, C` → `0x66`       |
| CMP     | RR     | 0xA0      | `CMP A, B` → `0xA1`       |

#### Операции с непосредственным значением

| Команда | Формат | Код (HEX) | Пример                     |
|---------|--------|-----------|----------------------------|
| MOV     | IMM8   | 0x70      | `MOV B, 0xFF` → `0x71 0xFF`|
| ADD     | IMM8   | 0x80      | `ADD A, 0x55` → `0x80 0x55`|

#### Работа с памятью

| Команда         | Формат  | Код (HEX) | Пример                          |
|-----------------|---------|-----------|---------------------------------|
| MOV [ADDR16], R | ADDR16  | 0x90      | `MOV [0x1234], A` → `0x90 0x12 0x34` |
| MOV R, [ADDR16] | ADDR16  | 0xA0      | `MOV B, [0x5678]` → `0xA1 0x56 0x78` |

#### Ввод-вывод

| Команда | Формат | Код (HEX) | Пример                     |
|---------|--------|-----------|----------------------------|
| IN      | PORT8  | 0xB0      | `IN C, 0x02` → `0xB2 0x02` |
| OUT     | PORT8  | 0xC0      | `OUT 0x03, D` → `0xC3 0x03`|

#### Управление потоком

| Команда | Формат  | Код (HEX) | Пример                      |
|---------|---------|-----------|-----------------------------|
| JMP     | ADDR16  | 0xD0      | `JMP 0x1234` → `0xD0 0x12 0x34` |
| JZ      | ADDR16  | 0xD1      | `JZ 0x5678` → `0xD1 0x56 0x78`  |
| JC      | ADDR16  | 0xD2      | `JC 0x9ABC` → `0xD2 0x9A 0xBC`  |

#### Специальные команды

| Команда | Код (HEX) | Описание                |
|---------|-----------|-------------------------|
| NOP     | 0x00      | Нет операции            |
| HALT    | 0xEF      | Останов процессора      |
| RET     | 0xE0      | Возврат из подпрограммы |
| RETI    | 0xE1      | Возврат из прерывания   |
| EI      | 0xE2      | Разрешить прерывания    |
| DI      | 0xE3      | Запретить прерывания    |

### 3. Регистры

Доступно 4 регистра общего назначения (кодируются 2 битами):

| Регистр | Код |
|---------|-----|
| A       | 00  |
| B       | 01  |
| C       | 10  |
| D       | 11  |

## Директивы ассемблера

### ORG

Устанавливает адрес размещения последующего кода:

```asm
ORG 0x1000  ; Последующий код будет размещен начиная с адреса 0x1000
```

### DB

Определение байта данных:

```asm
DB 0x55     ; Записывает байт 0x55
DB 'A'      ; Записывает ASCII-код символа 'A' (0x41)
```

## Примеры программ

### Пример 1: Вывод значения в порт

```asm
ORG 0x0000
    MOV A, 0x41      ; Загружаем ASCII-код 'A'
    OUT 0x01, A      ; Выводим в порт 0x01
    HALT             ; Останавливаем процессор
```

### Пример 2: Условный переход

```asm
ORG 0x1000
    MOV A, 0x00
    MOV B, 0x01
    ADD A, B         ; A = A + B
    JZ label         ; Переход если результат 0
    HALT
label:
    MOV [0x2000], A  ; Сохраняем результат
    RET
```

### Пример 3: Обработчик прерывания

```asm
ORG 0xFFFE          ; Вектор прерываний
    DW handler      ; Указываем адрес обработчика

ORG 0x1000
handler:
    PUSH A          ; Сохраняем регистр
    IN A, 0x00      ; Читаем данные из порта
    MOV [0x1000], A ; Сохраняем в память
    POP A           ; Восстанавливаем регистр
    RETI            ; Возврат из прерывания
```

## Особенности кодировки

1. Все 16-битные адреса записываются в формате Big Endian:
   - `0x1234` → `0x12 0x34`

2. Регистровые операции (RR-формат) кодируются в 1 байт:
   - `MOV A, B` → `0001 0001` → `0x11`

3. Команды с адресами занимают 3 байта:
   - `JMP 0x1234` → `0xD0 0x12 0x34`

4. Команды ввода-вывода занимают 2 байта:
   - `IN A, 0x01` → `0xB0 0x01`
```
Основные изменения:
1. Полностью переработана таблица команд в соответствии с кодировкой Big Endian
2. Добавлены конкретные примеры кодировки для каждой команды
3. Уточнены форматы команд (RR, IMM8, ADDR16 и т.д.)
4. Добавлены примеры программ с реальными кодами операций
5. Улучшена структура документа для лучшей читаемости
6. Добавлены директивы DB для определения данных
7. Уточнена работа с прерываниями и стеком